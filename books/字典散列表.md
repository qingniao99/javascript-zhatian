# 字典和散列表
集合表示一组互不相同的元素（不重复的元素）。在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。字典也称作映射。
set(key,value)：向字典中添加新元素。

remove(key)：通过使用键值来从字典中移除键值对应的数据值。

has(key)：如果某个键值存在于这个字典中，则返回true，反之则返回false。

get(key)：通过键值查找特定的数值并返回。

clear()：将这个字典中的所有元素全部删除。

size()：返回字典所包含元素的数量。与数组的length属性类似。

keys()：将字典所包含的所有键名以数组形式返回。

values()：将字典所包含的所有数值以数组形式返回。
# 散列表
散列算法的作用是尽可能快地在数据结构中找到一个值。在之前的章节中，你已经知道如果要在数据结构中获得一个值（使用get方法），需要遍历整个数据结构来找到它。如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值。散列函数的作用是给定一个键值，然后返回值在表中的地址。
# 处理散列表中的冲突
## 1. 分离链接
   分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单的方法，但是它在HashTable实例之外还需要额外的存储空间。
## 2. 线性探查
   另一种解决冲突的方法是线性探查。当想向表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置。如果index+1的位置也被占据了，就尝试index+2的位置，以此类推
## 7.2.5　创建更好的散列函数
   我们实现的“lose lose”散列函数并不是一个表现良好的散列函数，因为它会产生太多的冲突。如果我们使用这个函数的话，会产生各种各样的冲突。一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），当然也包括较低的冲突可能性。我们可以在网上找到一些不同的实现方法，或者也可以实现自己的散列函数。
   另一个可以实现的比“lose lose”更好的散列函数是djb2：
```javascript
var djb2HashCode = function (key) {
       var hash = 5381; //{1}
       for (var i = 0; i < key.length; i++) { //{2}
           hash = hash * 33 + key.charCodeAt(i); //{3}
       }
       return hash % 1013; //{4}
   };
```

   它包括初始化一个hash变量并赋值为一个质数（行{1}——大多数实现都使用5381），然后迭代参数key（行{2}），将hash与33相乘（用来当作一个魔力数），并和当前迭代到的字符的ASCII码值相加（行{3}）。

   最后，我们将使用相加的和与另一个随机质数（比我们认为的散列表的大小要大——在本例中，我们认为散列表的大小为1000）相除的余数。

这并不是最好的散列函数，但这是最被社区推荐的散列函数之一。


